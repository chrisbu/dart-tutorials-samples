import "dart:async" as SB;import "dart:indexed_db" as QC;import "dart:collection" as wB;import "dart:isolate" as jE;import "dart:html" as m;class LE{static const  ME="Chrome";static const  NE="Firefox";static const  OE="Internet Explorer";static const  PE="Safari";final  BE;final  minimumVersion;const LE(this.BE,[this.minimumVersion]);}class QE{final  name;const QE(this.name);}var TB=new nC(); mC(){}class nC{var lB=null;var HE=QC.IdbFactory.supported;var qE=new pC(); get GE=>(GB.length==0)?false:true; get GB=>qE.GB; start(){if(!HE){return new SB.Future.error('IndexedDB not supported.');}return qE.open().then((rE){sE();});} stop(){tE(true);} GC( h, g){if(g.isAfter(new DateTime.now())){qE.add(h,g).then((rE){sE();},onError:(i){print('duplicate key');});}} NC( g){return qE.remove(g).then((rE){tE(false);});} clear(){return qE.clear().then((rE){tE(false);});} sE(){if(lB==null&&GB.length>0){var g=new Duration(seconds:1);lB=new SB.Timer.periodic(g,uE);}} tE( g){if(g||(lB!=null&&GB.where((h)=>!h.elapsed).isEmpty)){lB.cancel();lB=null;}} uE( rE){for(int g=0;g<GB.length;g++ ){GB[g].IE();}}} oC(){var vE=m.document.body;var wE;var xE=new oB(vE);wE=vE.nodes[5];xE.XB(new RE()..host=wE);xE.PB();xE.insert();}main(){UC=true;mC();oC();}class LB extends s{final  eB;final  dB;var yE; get sB{if(q){v(this,k.p,'dbKey');}return yE;}set sB( g){if(BB(this)){n(this,k.p,'dbKey',yE,g);}yE=g;}var AF=new Duration(); get OC{if(q){v(this,k.p,'timeRemaining');}return AF;}set OC( g){if(BB(this)){n(this,k.p,'timeRemaining',AF,g);}AF=g;}LB(this.eB,this.dB); toString()=>'${eB} ${dB}';LB.kE(h, g):yE=h,eB=g['milestoneName'],dB=DateTime.parse(g['happensOn']){} KE(){return {'milestoneName':eB,'happensOn':dB.toString()};} get elapsed{return new DateTime.now().isAfter(dB);} IE(){OC=dB.difference(new DateTime.now());}}class pC{static const  JB='milestoneStore';static const  qC='name_index';final  GB=BD(new List());var BF; open(){return m.window.indexedDB.open('milestoneDB',version:1,onUpgradeNeeded:CF).then(DF);} CF( g){var h=(g.target as QC.Request).result;var i=h.createObjectStore(JB,autoIncrement:true);i.createIndex(qC,'milestoneName',unique:true);} DF( g){BF=g;var j=g.transaction(JB,'readonly');var l=j.objectStore(JB);var h=l.openCursor(autoAdvance:true).asBroadcastStream();h.listen((i){var o=new LB.kE(i.key,i.value);GB.add(o);});return h.length.then((EF){return GB.length;});} add( l, u){var g=new LB(l,u);var i=g.KE();var h=BF.transaction(JB,'readwrite');var o=h.objectStore(JB);o.add(i).then((j){g.sB=j;});return h.completed.then((EF){GB.add(g);return g;});} remove( g){var h=BF.transaction(JB,'readwrite');h.objectStore(JB).delete(g.sB);return h.completed.then((EF){g.sB=null;GB.remove(g);});} clear(){var g=BF.transaction(JB,'readwrite');g.objectStore(JB).clear();return g.completed.then((EF){GB.clear();});}}class RE extends DC with s{var FF;static final rC=new m.Element.tag('template'),sC=new m.Element.html('<li>\n                    <div is="x-milestone">\n                    </div>\n                  </li>'),tC=new m.DocumentFragment.html('''
          
          <div>
            <p>Enter a milestone</p>
            
            <input type="text" name="newMilestoneName">
            <input type="date" name="newMilestoneDate">
            <input type="time" name="newMilestoneTime">
            <button id="addbutton">+</button>
            
            <ul>
              <template></template>
            </ul>
          </div>
          <div>
            <button id="clearbutton">Clear</button>
            <p style="color:red"></p>
          </div>
          
        ''');var GF,HF;var IF;var JF,KF,LF;var MF;var NF; bC(){var OF=createShadowRoot("x-count-down");kC("x-count-down",new rB({"x-count-down":"[is=\"x-count-down\"]"}));FF=dC("x-count-down");NF=new oB(OF);OF.nodes.add(tC.clone(true));JF=OF.nodes[1].nodes[3];NF.listen(JF.onInput,(h){KC=JF.value;});NF.vB(()=>KC,(g){if(JF.value!=g)JF.value=g;},false,false);KF=OF.nodes[1].nodes[5];NF.listen(KF.onInput,(h){JC=KF.value;});NF.vB(()=>JC,(g){if(KF.value!=g)KF.value=g;},false,false);LF=OF.nodes[1].nodes[7];NF.listen(LF.onInput,(h){LC=LF.value;});NF.vB(()=>LC,(g){if(LF.value!=g)LF.value=g;},false,false);GF=OF.nodes[1].nodes[9];NF.listen(GF.onClick,(h){GC();});IF=OF.nodes[1].nodes[11].nodes[1];NF.EE(IF,()=>TB.GE,(NF){var PF;PF=rC.clone(true);NF.loop(PF,()=>TB.GB,(j,i,NF){var l=j[i];var QF,RF;RF=sC.clone(true);QF=RF.nodes[1];NF.vB(()=>l,(g){if(QF.xtag.QB!=g)QF.xtag.QB=g;},false,false);NF.XB(new SE()..host=QF);NF.addAll([new m.Text('\n                  '),RF,new m.Text('\n                ')]);});NF.addAll([new m.Text('\n                '),PF,new m.Text('\n              ')]);});HF=OF.nodes[3].nodes[1];NF.listen(HF.onClick,(h){clear();});MF=OF.nodes[3].nodes[3];var SF=NF.aC(()=>tB,false);MF.nodes.addAll([new m.Text(' '),SF,new m.Text(' ')]);NF.PB();} fC(){NF.insert();} jC(){NF.remove();NF=JF=KF=LF=GF=IF=HF=MF=null;}var TF=''; get tB{if(q){v(this,k.p,'errorMsg');}return TF;}set tB( g){if(BB(this)){n(this,k.p,'errorMsg',TF,g);}TF=g;}var KC="New Year's Day";var JC='2014-01-01';var LC='00:00:00'; GC(){var g=JC+' '+LC;var h=DateTime.parse(g);TB.GC(KC,h);} clear(){tB='';TB.clear();} eC(){TB.start().catchError((g){(m.query('#addbutton') as m.ButtonElement).disabled=true;(m.query('#clearbutton') as m.ButtonElement).disabled=true;tB=g.toString();});} iC(){TB.stop();}}class SE extends DC with s{var VF;static final uC=new m.DocumentFragment.html('''
        <span></span> <button>-</button>
      ''');var WF;var XF;var YF; bC(){var ZF=createShadowRoot("x-milestone");kC("x-milestone",new rB({"x-milestone":"[is=\"x-milestone\"]"}));VF=dC("x-milestone");YF=new oB(ZF);ZF.nodes.add(uC.clone(true));XF=ZF.nodes[1];var aF=YF.aC(()=>JE,false);XF.nodes.add(aF);WF=ZF.nodes[3];YF.listen(WF.onClick,(g){NC();});YF.PB();} fC(){YF.insert();} jC(){YF.remove();YF=XF=WF=null;}var bF; get QB{if(q){v(this,k.p,'milestone');}return bF;}set QB( g){if(BB(this)){n(this,k.p,'milestone',bF,g);}bF=g;}var dF=''; get eF{if(q){v(this,k.p,'_displayString');}return dF;}set eF( g){if(BB(this)){n(this,k.p,'_displayString',dF,g);}dF=g;} get JE{if(QB.elapsed){eF='Huzzah for ${QB.eB}!';return eF;}var g=QB.OC;var h=g.inDays;var j=g.inHours.remainder(Duration.HOURS_PER_DAY);var i=g.inMinutes.remainder(Duration.MINUTES_PER_HOUR);var RB=g.inSeconds.remainder(Duration.SECONDS_PER_MINUTE);var u=(h==0)?'':'${h} days, ';var l=(j==0)?'':'${j} hours, ';var o=(i==0)?'':'${i} minutes, ';var IB='${RB} seconds';eF='${u} ${l} ${o} ${IB} until ${QB.eB}';return eF;} NC(){TB.NC(QB);}}class vC<MB> extends TD with s implements List<MB>{final  fF;vC([ g]):fF=g!=null?new List<MB>(g):<MB>[] ;factory vC.lE( g)=>new vC<MB>()..addAll(g); get length{if(q)v(this,k.p,'length');return fF.length;}set length( h){var i=fF.length;if(i==h)return;if(BB(this)){if(h<i){for(int g=i-1;g>=h;g-- ){n(this,k.OB,g,fF[g],null);}n(this,k.p,'length',i,h);}else{n(this,k.p,'length',i,h);for(int g=i;g<h;g++ ){n(this,k.UB,g,null,null);}}}fF.length=h;} operator[]( g){if(q)v(this,k.HB,g);return fF[g];}operator[]=( g, h){var i=fF[g];if(BB(this)){n(this,k.HB,g,i,h);}fF[g]=h;} sublist( h,[ g])=>new vC<MB>.lE(super.sublist(h,g)); add( h){var g=fF.length;if(BB(this)){n(this,k.p,'length',g,g+1);n(this,k.UB,g,null,h);}fF.add(h);} removeRange( h, g){if(g==0)return;SC.RD(this,h,g);if(BB(this)){for(int i=h;i<g;i++ ){n(this,k.OB,i,this[i],null);}}SC.QD(this,h+g,this,h,this.length-g-h);this.length=this.length-g;} toString(){if(q){for(int g=0;g<length;g++ ){v(this,k.HB,g);}}return fF.toString();}}typedef  fB<w,t>();class YB<w,t> extends s implements Map<w,t>{final  gF;var hF;var iF;YB({ createMap}):gF=createMap!=null?createMap():new Map<w,t>(){hF=new wC<w,t>(this);iF=new xC<w,t>(this);}factory YB.mE( i,{ createMap}){var g=new YB<w,t>(createMap:createMap);i.forEach(( h, j){g[h]=j;});return g;} get keys=>hF; get values=>iF; get length{if(q)v(this,k.p,'length');return gF.length;} get isEmpty=>length==0; get isNotEmpty=>length!=0; jF( g)=>v(this,k.HB,g); kF(){v(this,k.p,'length');gF.keys.forEach(jF);} containsKey( g){if(q)jF(g);return gF.containsKey(g);} operator[]( g){if(q)jF(g);return gF[g];} operator[]=( h, g){var j=gF.length;var i=gF[h];gF[h]=g;if(BB(this)){if(j!=gF.length){n(this,k.p,'length',j,gF.length);n(this,k.UB,h,i,g);}else if(i!=g){n(this,k.HB,h,i,g);}}} putIfAbsent( g, j()){if(q)jF(g);var h=gF.length;var i=gF.putIfAbsent(g,j);if(BB(this)&&h!=gF.length){n(this,k.p,'length',h,gF.length);n(this,k.UB,g,null,i);}return i;} remove( g){if(q)jF(g);var h=gF.length;var i=gF.remove(g);if(BB(this)&&h!=gF.length){n(this,k.OB,g,i,null);n(this,k.p,'length',h,gF.length);}return i;} addAll( h)=>h.forEach((g,i){this[g]=i;}); clear(){var g=gF.length;if(BB(this)&&g>0){gF.forEach((i,h){n(this,k.OB,i,h,null);});n(this,k.p,'length',g,0);}gF.clear();} forEach( g( key, value)){if(q)kF();gF.forEach(g);} toString()=>wB.Maps.mapToString(this);}class wC<w,t> extends wB.IterableBase<w>{final  gF;wC(this.gF); get iterator=>new TE<w,t>(gF);}class TE<w,t> implements Iterator<w>{final  gF;final  hF;var lF=false;TE( g):gF=g,hF=g.gF.keys.iterator; moveNext(){if(q)v(gF,k.p,'length');return lF=hF.moveNext();} get current{var g=hF.current;if(q&&lF)gF.jF(g);return g;}}class xC<w,t> extends wB.IterableBase<t>{final  gF;xC(this.gF); get iterator=>new UE<w,t>(gF);}class UE<w,t> implements Iterator<t>{final  gF;final  hF;final  iF;var lF;UE( g):gF=g,hF=g.gF.keys.iterator,iF=g.gF.values.iterator; moveNext(){if(q)v(gF,k.p,'length');var h=hF.moveNext();var g=iF.moveNext();if(h!=g){throw new StateError('keys and values should be the same length');}return lF=g;} get current{if(q&&lF)gF.jF(hF.current);return iF.current;}}const VE=const WE();typedef  KB( e);typedef  yC( changes);typedef  NB();typedef  zC();class mB{final oldValue;final newValue;final  changes;mB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is mB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>ND(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class k{static const p=1;static const HB=2;static const UB=HB|4;static const OB=HB|8;final  type;final key;final oldValue;final newValue;k(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is k&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>OD(type,key,oldValue,newValue); toString(){var g;switch (type){case p:g='field';break;case HB:g='index';break;case UB:g='insert';break;case OB:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}} AD(g, i,[ l]){if(g is s){var h=g;return xB(h,(o){i(new mB(h,h,o));});}var j=new nB(g,i,l);if(!j.mF()){return DD;}return j.nF;} xB( g, i){if(g.cB==null)g.cB=new zB();var h=g.cB.add(i);return h.remove;}BD(g){if(g is Map){var h=null;if(g is wB.SplayTreeMap){h=()=>new wB.SplayTreeMap();}else if(g is wB.LinkedHashMap){h=()=>new wB.LinkedHashMap();}return new YB.mE(g,createMap:h);}if(g is Set)return new yB.nE(g);if(g is Iterable)return new vC.lE(g);return g;}class s{var cB;var bB;final  hashCode= ++s.CD;static var CD=0;} BB( g)=>g.cB!=null&&g.cB.head!=null; get q=>ZB!=null; v( g, h,i)=>ZB.oF(g,h,i); n( g, j,l, h, i){if((j&(k.UB|k.OB))==0){if(h==i)return;}if(VB==null){VB=[] ;PD(ED);}if(g.bB==null){g.bB=[] ;VB.add(g);}g.bB.add(new k(j,l,h,i));} DD(){}var ZB;var RC=100;var VB;var WB; ED(){var o=0;while (VB!=null||WB!=null){var j=VB;VB=null;var i=WB;WB=null;if(o++ ==RC){FD(j,i);return;}if(j!=null){for(var h in j){var IB=h.bB;h.bB=null;for(var g=h.cB.head;g!=null;g=g.next){var l=g.value;try {l(IB);}catch (RB,u){gB(RB,u,l,'from ${h}');}}}}if(i!=null){i.forEach((iE,PC){PC.pF();});}}} FD( l, j){var g=[] ;if(l!=null){for(var i in l){var IB=i.bB;g.add('${i} ${IB}');}}if(j!=null){for(var o in j.values){var h=o.pF();if(h!=null)g.add('${o} ${h}');}}VB=null;WB=null;var u='exceeded notifiction limit of ${RC}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';ID(u);}class nB{static var GD=0;final  qF= ++nB.GD;final  rF;final  sF;final  tF;final  uF=new Map();final  vF=[] ;var wF=false;var xF;nB(this.rF,this.sF,this.tF); toString()=>tF!=null?'<observer ${qF}: ${tF}>':'<observer ${qF}>'; mF(){var h=ZB;ZB=this;try {xF=rF();if(xF is Iterable&&xF is !List&&xF is !s){xF=(xF as Iterable).toList();}}catch (g,i){gB(g,i,rF,'from ${this}');xF=null;}uF.forEach(yF);uF.clear();assert(ZB==this);ZB=h;zF();return vF.length>0;} AG( i){try {sF(i);}catch (g,h){gB(g,h,sF,'from ${this}');}} zF(){var g=xF;if(g is !s)return;vF.add(xB(g,(h){AG(new mB(g,g,h));}));} oF( o, u,g){var i=uF.putIfAbsent(o,()=>new Map());try {var h=i[g];if(h==null)h=0;i[g]=h|u;}catch (j,l){gB(j,l,g,'hashCode or operator == from ${this}');}} yF( i, j){vF.add(xB(i,(l){if(wF)return;for(var g in l){var h=j[g.key];if(h!=null&&(h&g.type)!=0){wF=true;if(WB==null){WB=new wB.SplayTreeMap();}WB[qF]=this;return;}}}));} nF(){for(var g in vF){g();}wF=false;} pF(){if(!wF)return null;var g=xF;nF();mF();try {if(g==xF)return null;}catch (i,j){gB(i,j,g,'operator == from ${this}');return null;}var h=new mB(g,xF);AG(h);return h;}}typedef  HD( message);var ID=(g)=>print(g);typedef  JD(error,stackTrace,obj, message);var gB=KD; KD(i,g,h, j){print('web_ui.observe: unhandled error calling ${h} ${j}.\n' 'error:\n${i}\n\nstack trace:\n${g}');}class WE{const WE();}class yB<CB> extends SD with s implements Set<CB>{final  BG;final  CG;yB({ createMap}):BG=createMap!=null?createMap():new Map<CB,Object>(),CG=createMap;factory yB.nE( g,{ createMap}){return new yB<CB>(createMap:createMap)..addAll(g);} contains( g){if(q)v(this,k.HB,g);return BG.containsKey(g);} add( g){var h=BG.length;BG[g]=const Object();if(h!=BG.length){n(this,k.p,'length',h,BG.length);n(this,k.UB,g,null,g);}} remove( g){if(q)v(this,k.HB,g);var h=BG.length;BG.remove(g);if(h!=BG.length){if(BB(this)){n(this,k.OB,g,g,null);n(this,k.p,'length',h,BG.length);}return true;}return false;} clear(){if(BB(this)){for(var g in BG.keys){n(this,k.OB,g,g,null);}n(this,k.p,'length',BG.length,0);}BG.clear();} get length{if(q)v(this,k.p,'length');return BG.length;} get isEmpty=>length==0; get iterator=>new XE<CB>(this); addAll( g)=>g.forEach(add); difference( i){var h=new yB<CB>(createMap:CG);for(CB g in this){if(!i.contains(g))h.add(g);}return h;} toString(){if(q){for(CB g in BG.keys){v(this,k.HB,g);}}return BG.keys.toSet().toString();}}class XE<CB> implements Iterator<CB>{final  DG;final  EG;var FG=false;XE( g):DG=g,EG=g.BG.keys.iterator; moveNext(){DG.length;return FG=EG.moveNext();} get current{var g=EG.current;if(q&&FG)v(DG,k.HB,g);return g;}}class LD{}class MD{}class EB<FB>{var GG;var HG;var IG;var JG;EB.oE( g,this.IG):JG=g{if(IG!=null)IG.KG++ ;} get next=>HG; get value=>JG;set value( g)=>JG=g; LG( g, h){HG=h;GG=g;if(g!=null)g.HG=this;if(h!=null)h.GG=this;return this;} append( g)=>new EB<FB>.oE(g,IG).LG(this,HG); remove(){if(IG==null)return;IG.KG-- ;if(GG!=null){GG.HG=HG;}else{IG.MG=HG;}if(HG!=null){HG.GG=GG;}else{IG.NG=GG;}HG=null;GG=null;IG=null;}}class zB<FB> extends wB.IterableBase<FB>{var MG;var NG; get length=>KG;var KG=0;zB(){} get head=>MG; add( h){var g=new EB<FB>.oE(h,this);if(NG==null)return MG=NG=g;return NG=g.LG(NG,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new YE<FB>(this);}class YE<FB> implements Iterator<FB>{var OG;var IG;var PG;var QG=-1;YE(this.IG){OG=new List<EB>(IG.length);var h=0;var g=IG.head;while (g!=null){OG[h++ ]=g;g=g.next;}} get current=>PG; moveNext(){do{QG++ ;}while(QG<OG.length&&OG[QG].IG!=IG);if(QG<OG.length){PG=OG[QG].value;return true;}else{PG=null;return false;}}}hB(h,g)=>h.hashCode*31+g.hashCode;ND(h,g,i)=>hB(hB(h,g),i);OD(g,i,h,j)=>hB(hB(g,i),hB(h,j)); PD( h()){var g=new jE.ReceivePort();g.receive((i,j){g.close();h();});g.toSendPort().send(null);}class SC{static  QD( o, g, u, i, l){if(g==null)g=0;if(i==null)i=0;if(g<i){for(int h=g+l-1,j=i+l-1;h>=g;h-- ,j-- ){u[j]=o[h];}}else{for(int h=g,j=i;h<g+l;h++ ,j++ ){u[j]=o[h];}}}static  RD( j, h, g){if(g<0){throw new ArgumentError("negative length ${g}");}if(h<0){var i="${h} must be greater than or equal to 0";throw new RangeError(i);}if(h+g>j.length){var i="${h} + ${g} must be in the range [0..${j.length})";throw new RangeError(i);}}}abstract class SD extends wB.IterableBase<dynamic>{}abstract class TD extends wB.ListMixin<dynamic>{} UD(i, g,[ h]){var j=i is LD;if(h==null){h=i.toString();}if(!j&&g is m.Text){g.text=h;}else{var l=g;g=j?new m.Element.html(h):new m.Text(h);l.replaceWith(g);}return g;} VD(g){if(g is MD)return g.toString();g=g.toString();return XD(g)?g:'#';}const WD=const["http","https","ftp","mailto"]; XD( h){var g=Uri.parse(h).scheme;if(g=='')return true;return WD.contains(g.toLowerCase())||"MAILTO"==g.toUpperCase();}abstract class aB{ PB(){} insert(); remove();}class ZE extends aB{final  cC;var RG;final  listener;ZE(this.cC,this.listener); insert(){RG=cC.listen(listener);} remove(){RG.cancel();RG=null;}}class aE extends aB{final exp;final  action;final  isFinal;var AB;aE(this.exp,this.action,this.isFinal); insert(){if(isFinal){action(new mB(null,exp()));}else if(AB!=null){throw new StateError('binding already attached');}else{AB=pB(exp,action,'generic-binding');}} remove(){if(!isFinal){AB();AB=null;}}}class bE extends aB{final  lC;final  IC;final  gC;final  isFinal;var AB;bE(this.IC,this.lC,this.gC,this.isFinal); SG(g){lC(gC?VD(g):g);} insert(){if(isFinal){SG(IC());}else if(AB!=null){throw new StateError('data binding already attached.');}else{AB=pB(IC,(g)=>SG(g.newValue),'dom-property-binding');}} remove(){if(!isFinal){AB();AB=null;}}}class cE extends aB{final XB;cE(this.XB); PB(){XB..bC()..FE()..DE();} insert(){XB..eC()..fC();} remove(){XB..jC()..iC();}}class oB extends aB{final  MC;final  children=[] ;final  nodes=[] ;oB(this.MC); listen( i, h){children.add(new ZE(i,(g){h(g);dD();}));} aC( h,i){var g=new m.Text('');children.add(new aE(()=>'${h()}',(j){g=UD(h(),g,j.newValue);},i));return g;} vB(g,j,h,[i=false]){children.add(new bE(g,j,i,h));} EE( h,g,i){children.add(new ZD(h,g,i));} loop( h,g,i){children.add(new dE(h,g,i));} XB( g){children.add(new cE(g));} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); PB(){for(var g=0,h=children.length;g<h;g++ ){children[g].PB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}abstract class TC extends oB{final exp;var AB;TC( g,this.exp):super(g); PB(){} insert(){super.PB();if(nodes.length>0){var i=MC.parentNode;var j=MC.nextNode;for(var g=0,h=nodes.length;g<h;g++ ){i.insertBefore(nodes[g],j);}}super.insert();} remove(){super.remove();for(var g=nodes.length-1;g>=0;g-- ){nodes[g].remove();}nodes.clear();}}typedef  YD( template);class ZD extends TC{var uB=false;final  ZC;ZD( h,g,this.ZC):super(h,g); insert(){AB=pB(exp,(g){if(!uB&&g.newValue){ZC(this);super.insert();uB=true;}else if(uB&&!g.newValue){super.remove();uB=false;}},'conditional-binding');} remove(){super.remove();AB();AB=null;}}typedef  aD( list, index, template);class dE extends TC{final  hC;dE( h,g,this.hC):super(h,g); insert(){AB=pB(exp,(i){super.remove();var h=i.newValue;for(int g=0;g<h.length;g++ ){hC(h,g,this);}super.insert();},'loop-binding');} remove(){super.remove();AB();AB=null;}}var UC=false; bD(g, o,[ l]){if(UC)return AD(g,o);if(o==null)return (){};if(iB==null)iB=new zB<jB>();var i;var h=DB.hD;if(g is XC){i=(g as XC).TG;}else if(g is Function){i=g;try {var j=g();if(j is List){h=DB.kB;}else if(j is Iterable){h=DB.kB;i=()=>g().toList();}else if((j is wB.LinkedHashMap)||(j is wB.SplayTreeMap)){h=DB.CC;}else if(j is Map){h=DB.BC;}}catch (IB,PC){print('error: evaluating ${l!=null?l:"<unnamed>"} ' 'watcher threw error (${IB}, ${PC})');}}else if(g is List){i=()=>g;h=DB.kB;}else if(g is Iterable){i=()=>g.toList();h=DB.kB;}else if((g is wB.LinkedHashMap)||(g is wB.SplayTreeMap)){i=()=>g;h=DB.CC;}else if(g is Map){i=()=>g;h=DB.BC;}var u=cD(h,i,o,l);var RB=iB.add(u);return RB.remove;} cD( j, g, i, h){switch (j){case DB.kB:return new eE(g,i,h);case DB.CC:return new gE(g,i,h);case DB.BC:return new fE(g,i,h);default:return new jB(g,i,h);}} pB(h,i,[j]){var l=bD(h,i,j);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new mB(null,g));return l;}var iB;class jB{final  HC;final  TG;final  UG;var VG;jB(this.TG,this.UG,this.HC){VG=TG();} toString()=>HC==null?'<unnamed>':HC; CE(){var g=WG();if(XG(g)){var h=VG;YG(g);UG(new mB(h,g));return true;}return false;} XG(g)=>VG!=g; YG(g){VG=g;}WG(){try {return TG();}catch (g,h){print('error: evaluating ${this} watcher threw an exception (${g}, ${h})');}return VG;}}final  VC=10; dD(){if(iB==null)return;var g;var h=0;do{g=false;for(var i in iB){if(i.CE()){g=true;}}}while(g&& ++h<VC);if(h==VC){print('Possible loop in watchers propagation, stopped dispatch.');}}typedef  WC<eD>();typedef  fD<eD>( value);class XC<eD>{}class eE<eD> extends jB{eE(g, i, h):super(g,i,h){YG(WG());} XG( g){return AC(VG,g);} YG(g){VG=new List<eD>.from(g);}}class fE<qB,gD> extends jB{fE(g, i, h):super(g,i,h){YG(WG());} XG( g){var i=VG.keys;if(i.length!=g.keys.length)return true;var j=i.iterator;while (j.moveNext()){var h=j.current;if(!g.containsKey(h))return true;if(VG[h]!=g[h])return true;}return false;} YG(g){VG=new Map<qB,gD>.from(g);}}class gE<qB,gD> extends jB{gE(g, i, h):super(g,i,h){YG(WG());} XG( g){return AC(g.keys,VG.keys)||AC(g.values,VG.values);} YG(g){VG=new wB.LinkedHashMap.from(g);}} AC( i, j){var h=i.iterator;var g=j.iterator;while (h.moveNext()){if(!g.moveNext())return true;if(h.current!=g.current)return true;}return g.moveNext();}class DB{final ZG;const DB.pE(this.ZG);toString()=>'Enum.${ZG}';static const kB=const DB.pE('LIST');static const BC=const DB.pE('HASH_MAP');static const CC=const DB.pE('ORDERED_MAP');static const hD=const DB.pE('OTHER');}abstract class DC implements m.Element{var aG;var bG;var cG={};var dG=new rB({}); dC( g)=>dG; kC( h,var g){dG=g;} get host{if(aG==null)throw new StateError('host element has not been set.');return aG;}set host( g){if(g==null){throw new ArgumentError('host must not be null.');}var h=g.xtag;if(h!=null&&h!=g){throw new ArgumentError('host must not have its xtag property set.');}if(aG!=null){throw new StateError('host can only be set once.');}g.xtag=this;aG=g;}createShadowRoot([ g]){var h=eG();if(g!=null){cG[g]=h;}return h;}eG(){if(YC){return host.createShadowRoot();}if(bG==null)bG=[] ;bG.add(new m.DivElement());return bG.last;} FE(){} eC(){} iC(){} DE(){if(YC)return;if(bG.length==0){throw new StateError('Distribution algorithm requires at least one shadow' ' root and can only be run once.');}var j=bG;var g=j.removeLast();var u=g;var o=new List.from(nodes);var l=[] ;var IB=[] ;while (true){o=fG(g,o);var h=g.query('shadow');if(h!=null){if(j.length>0){g=j.removeLast();l.add(h);IB.add(g);}else{FC(h,o);break;}}else{break;}}for(int i=0;i<l.length;i++ ){var h=l[i];var g=IB[i];FC(h,g.nodes);}nodes.clear();nodes.addAll(u.nodes);for(var RB in cG.keys){if(cG[RB]==u){cG[RB]=this;break;}}} fG( u, j){for(var g in u.queryAll('content')){if(!jD(g))continue;var i=g.attributes['select'];if(i==null||i=='')i='*';var h=[] ;var o=[] ;for(var l in j){(iD(l,i)?h:o).add(l);}if(h.length==0){h=g.nodes;}FC(g,h);j=o;}return j;}static  iD( h, g){if(h is !m.Element)return g=='*';return (h as m.Element).matches(g);}static  EC( g)=>g.tagName=='CONTENT'||g.tagName=='SHADOW';static  jD( g){assert(EC(g));for(g=g.parent;g!=null;g=g.parent){if(EC(g))return false;}return true;}static  FC( g, h){assert(EC(g));g.parent.insertAllBefore(h,g);g.remove();} get nodes=>host.nodes; replaceWith( g){host.replaceWith(g);} remove()=>host.remove(); get nextNode=>host.nextNode;set text( g){host.text=g;} contains( g)=>host.contains(g); insertBefore( g, h)=>host.insertBefore(g,h); insertAllBefore( g, h)=>host.insertAllBefore(g,h); get attributes=>host.attributes; get children=>host.children; clone( g)=>host.clone(g); get parent=>host.parent; get parentNode=>host.parentNode; get nodeValue=>host.nodeValue; get id=>host.id;set id( g){host.id=g;} set innerHtml( g){host.innerHtml=g;} get tagName=>host.tagName; matches( g)=>host.matches(g); query( g)=>host.query(g); queryAll( g)=>host.queryAll(g); get oD=>host.oD; get pD=>host.pD; get sD=>host.sD; qD( g)=>host.qD(g); rD( g)=>host.rD(g); vD( g)=>host.vD(g); wD( g)=>host.wD(g); AE( h, g)=>host.AE(h,g);get mD=>host.mD; get nD=>host.nD; get localName=>host.localName; get tD=>host.tD; get uD=>host.uD; lD( i, g,[ h]){host.lD(i,g,h);} xD( g)=>host.xD(g); yD( i, g,[ h]){host.yD(i,g,h);} zD( g, h)=>host.zD(g,h);get xtag=>host.xtag;set xtag(g){host.xtag=g;} append( g)=>host.append(g); get onClick=>host.onClick; get onInput=>host.onInput;}class rB{final  gG;rB(this.gG); operator[]( g)=>gG[g];}var kD=false; get YC=>kD&&m.ShadowRoot.supported;//@ sourceMappingURL=count_down.html_bootstrap.dart.map
