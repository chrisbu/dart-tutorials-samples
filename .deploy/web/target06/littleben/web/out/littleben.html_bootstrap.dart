import "dart:collection" as aB;import "dart:html" as w;import "dart:isolate" as cC;import "dart:async" as PC;class QC{static const  RC="Chrome";final  MC;final  minimumVersion;const QC(this.MC,[this.minimumVersion]);}class SC{final  name;const SC(this.name);}final MB=new l();var NB; get hB{if(qB){rB(MB,s.OB,'currentTime');}return NB;}set hB( g){if(pB(MB)){sB(MB,s.OB,'currentTime',NB,g);}NB=g;} iB(){var g=new Duration(seconds:1);new PC.Timer.periodic(g,bB);bB(null);} bB( gC){var g=new DateTime.now();hB=jB(g.hour,g.minute,g.second);} jB( g, h, i){if(g>12){g=g-12;}var j=(h<=9)?'0${h}':'${h}';var k=(i<=9)?'0${i}':'${i}';return '${g}:${j}:${k}';} kB(){var hC=w.document.body;var iC;var jC=new VC(hC);iC=hC.nodes[3];var kC=jC.NC(()=>hB,false);iC.nodes.addAll([new w.Text('\n      The current time is: '),kC,new w.Text('\n    ')]);jC.WB();jC.insert();}main(){fB=true;iB();kB();}typedef  q( e);typedef  lB( changes);typedef  AB();typedef  mB();class JB{final oldValue;final newValue;final  changes;JB(this.oldValue,this.newValue,[this.changes]); operator==(g){return g is JB&&oldValue==g.oldValue&&newValue==g.newValue&&changes==g.changes;} get hashCode=>CC(oldValue,newValue,changes); toString(){if(changes!=null)return '#<ChangeNotification to ${newValue}: ${changes}>';return '#<ChangeNotification from ${oldValue} to ${newValue}>';}}class s{static const OB=1;static const PB=2;static const cB=PB|4;static const dB=PB|8;final  type;final key;final oldValue;final newValue;s(this.type,this.key,this.oldValue,this.newValue); operator==(g){return g is s&&type==g.type&&key==g.key&&oldValue==g.oldValue&&newValue==g.newValue;} get hashCode=>DC(type,key,oldValue,newValue); toString(){var g;switch (type){case OB:g='field';break;case PB:g='index';break;case cB:g='insert';break;case dB:g='remove';break;}return '#<ChangeRecord ${g} ${key} from ${oldValue} to ${newValue}>';}} nB(g, i,[ k]){if(g is l){var h=g;return QB(h,(p){i(new JB(h,h,p));});}var j=new KB(g,i,k);if(!j.lC()){return tB;}return j.mC;} QB( g, i){if(g.DB==null)g.DB=new RB();var h=g.DB.add(i);return h.remove;}class l{var DB;var CB;final  hashCode= ++l.oB;static var oB=0;} pB( g)=>g.DB!=null&&g.DB.head!=null; get qB=>BB!=null; rB( g, h,i)=>BB.nC(g,h,i); sB( g, j,k, h, i){if((j&(s.cB|s.dB))==0){if(h==i)return;}if(t==null){t=[] ;EC(uB);}if(g.CB==null){g.CB=[] ;t.add(g);}g.CB.add(new s(j,k,h,i));} tB(){}var BB;var eB=100;var t;var u; uB(){var p=0;while (t!=null||u!=null){var j=t;t=null;var i=u;u=null;if(p++ ==eB){vB(j,i);return;}if(j!=null){for(var h in j){var IB=h.CB;h.CB=null;for(var g=h.DB.head;g!=null;g=g.next){var k=g.value;try {k(IB);}catch (ZB,v){EB(ZB,v,k,'from ${h}');}}}}if(i!=null){i.forEach((bC,YB){YB.oC();});}}} vB( k, j){var g=[] ;if(k!=null){for(var i in k){var IB=i.CB;g.add('${i} ${IB}');}}if(j!=null){for(var p in j.values){var h=p.oC();if(h!=null)g.add('${p} ${h}');}}t=null;u=null;var v='exceeded notifiction limit of ${eB}, possible ' 'circular reference in observer callbacks: ${g.take(10).join(", ")}';yB(v);}class KB{static var wB=0;final  pC= ++KB.wB;final  qC;final  rC;final  sC;final  tC=new Map();final  uC=[] ;var vC=false;var wC;KB(this.qC,this.rC,this.sC); toString()=>sC!=null?'<observer ${pC}: ${sC}>':'<observer ${pC}>'; lC(){var h=BB;BB=this;try {wC=qC();if(wC is Iterable&&wC is !List&&wC is !l){wC=(wC as Iterable).toList();}}catch (g,i){EB(g,i,qC,'from ${this}');wC=null;}tC.forEach(xC);tC.clear();assert(BB==this);BB=h;yC();return uC.length>0;} zC( i){try {rC(i);}catch (g,h){EB(g,h,rC,'from ${this}');}} yC(){var g=wC;if(g is !l)return;uC.add(QB(g,(h){zC(new JB(g,g,h));}));} nC( p, v,g){var i=tC.putIfAbsent(p,()=>new Map());try {var h=i[g];if(h==null)h=0;i[g]=h|v;}catch (j,k){EB(j,k,g,'hashCode or operator == from ${this}');}} xC( i, j){uC.add(QB(i,(k){if(vC)return;for(var g in k){var h=j[g.key];if(h!=null&&(h&g.type)!=0){vC=true;if(u==null){u=new aB.SplayTreeMap();}u[pC]=this;return;}}}));} mC(){for(var g in uC){g();}vC=false;} oC(){if(!vC)return null;var g=wC;mC();lC();try {if(g==wC)return null;}catch (i,j){EB(i,j,g,'operator == from ${this}');return null;}var h=new JB(g,wC);zC(h);return h;}}typedef  xB( message);var yB=(g)=>print(g);typedef  zB(error,stackTrace,obj, message);var EB=AC; AC(i,g,h, j){print('web_ui.observe: unhandled error calling ${h} ${j}.\n' 'error:\n${i}\n\nstack trace:\n${g}');}class BC{}class n<o>{var AD;var BD;var CD;var DD;n.dC( g,this.CD):DD=g{if(CD!=null)CD.ED++ ;} get next=>BD; get value=>DD;set value( g)=>DD=g; FD( g, h){BD=h;AD=g;if(g!=null)g.BD=this;if(h!=null)h.AD=this;return this;} append( g)=>new n<o>.dC(g,CD).FD(this,BD); remove(){if(CD==null)return;CD.ED-- ;if(AD!=null){AD.BD=BD;}else{CD.GD=BD;}if(BD!=null){BD.AD=AD;}else{CD.HD=AD;}BD=null;AD=null;CD=null;}}class RB<o> extends aB.IterableBase<o>{var GD;var HD; get length=>ED;var ED=0;RB(){} get head=>GD; add( h){var g=new n<o>.dC(h,this);if(HD==null)return GD=HD=g;return HD=g.FD(HD,null);} addLast( g)=>add(g); addAll( g)=>g.forEach(add); get iterator=>new TC<o>(this);}class TC<o> implements Iterator<o>{var ID;var CD;var JD;var KD=-1;TC(this.CD){ID=new List<n>(CD.length);var h=0;var g=CD.head;while (g!=null){ID[h++ ]=g;g=g.next;}} get current=>JD; moveNext(){do{KD++ ;}while(KD<ID.length&&ID[KD].CD!=CD);if(KD<ID.length){JD=ID[KD].value;return true;}else{JD=null;return false;}}}FB(h,g)=>h.hashCode*31+g.hashCode;CC(h,g,i)=>FB(FB(h,g),i);DC(g,i,h,j)=>FB(FB(g,i),FB(h,j)); EC( h()){var g=new cC.ReceivePort();g.receive((i,j){g.close();h();});g.toSendPort().send(null);} FC(i, g,[ h]){var j=i is BC;if(h==null){h=i.toString();}if(!j&&g is w.Text){g.text=h;}else{var k=g;g=j?new w.Element.html(h):new w.Text(h);k.replaceWith(g);}return g;}abstract class SB{ WB(){} insert(); remove();}class UC extends SB{final exp;final  action;final  isFinal;var LB;UC(this.exp,this.action,this.isFinal); insert(){if(isFinal){action(new JB(null,exp()));}else if(LB!=null){throw new StateError('binding already attached');}else{LB=IC(exp,action,'generic-binding');}} remove(){if(!isFinal){LB();LB=null;}}}class VC extends SB{final  OC;final  children=[] ;final  nodes=[] ;VC(this.OC); NC( h,i){var g=new w.Text('');children.add(new UC(()=>'${h()}',(j){g=FC(h(),g,j.newValue);},i));return g;} add( g)=>nodes.add(g); addAll( g)=>nodes.addAll(g); WB(){for(var g=0,h=children.length;g<h;g++ ){children[g].WB();}} insert(){for(var g=0,h=children.length;g<h;g++ ){children[g].insert();}} remove(){for(var g=children.length-1;g>=0;g-- ){children[g].remove();}children.clear();}}var fB=false; GC(g, p,[ k]){if(fB)return nB(g,p);if(p==null)return (){};if(TB==null)TB=new RB<GB>();var i;var h=m.LC;if(g is gB){i=(g as gB).LD;}else if(g is Function){i=g;try {var j=g();if(j is List){h=m.HB;}else if(j is Iterable){h=m.HB;i=()=>g().toList();}else if((j is aB.LinkedHashMap)||(j is aB.SplayTreeMap)){h=m.VB;}else if(j is Map){h=m.UB;}}catch (IB,YB){print('error: evaluating ${k!=null?k:"<unnamed>"} ' 'watcher threw error (${IB}, ${YB})');}}else if(g is List){i=()=>g;h=m.HB;}else if(g is Iterable){i=()=>g.toList();h=m.HB;}else if((g is aB.LinkedHashMap)||(g is aB.SplayTreeMap)){i=()=>g;h=m.VB;}else if(g is Map){i=()=>g;h=m.UB;}var v=HC(h,i,p,k);var ZB=TB.add(v);return ZB.remove;} HC( j, g, i, h){switch (j){case m.HB:return new WC(g,i,h);case m.VB:return new aC(g,i,h);case m.UB:return new XC(g,i,h);default:return new GB(g,i,h);}} IC(h,i,[j]){var k=GC(h,i,j);var g=h;if(g is Function){g=g();}if(g is Iterable&&g is !List){g=g.toList();}i(new JB(null,g));return k;}var TB;class GB{final  XB;final  LD;final  MD;var ND;GB(this.LD,this.MD,this.XB){ND=LD();} toString()=>XB==null?'<unnamed>':XB; OD(g){ND=g;}PD(){try {return LD();}catch (g,h){print('error: evaluating ${this} watcher threw an exception (${g}, ${h})');}return ND;}}typedef  JC<KC>();class gB<KC>{}class WC<KC> extends GB{WC(g, i, h):super(g,i,h){OD(PD());} OD(g){ND=new List<KC>.from(g);}}class XC<YC,ZC> extends GB{XC(g, i, h):super(g,i,h){OD(PD());} OD(g){ND=new Map<YC,ZC>.from(g);}}class aC<YC,ZC> extends GB{aC(g, i, h):super(g,i,h){OD(PD());} OD(g){ND=new aB.LinkedHashMap.from(g);}}class m{final QD;const m.eC(this.QD);toString()=>'Enum.${QD}';static const HB=const m.eC('LIST');static const UB=const m.eC('HASH_MAP');static const VB=const m.eC('ORDERED_MAP');static const LC=const m.eC('OTHER');}//@ sourceMappingURL=littleben.html_bootstrap.dart.map
